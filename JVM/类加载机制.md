# 类加载机制

## 加载过程
![](https://images2015.cnblogs.com/blog/907818/201603/907818-20160317231659365-766608088.jpg)


- 加载 （获取来自任意来源的字节流并转换成运行时数据结构，生成Class对象）
- 验证 （验证字节流信息符合当前虚拟机的要求，防止被篡改过的字节码危害JVM安全）
- 准备 （为类变量分配内存并设置初始值）
- 解析 （将常量池的符号引用替换为直接引用，符号引用是用一组符号来描述所引用的目标，直接引用是指向目标的指针）
- 初始化 （执行类构造器、类变量赋值、静态语句块）

## 类加载器
> 类加载器ClassLoader，它是一个抽象类，ClassLoader的具体实例负责把java字节码读取到JVM当中，ClassLoader还可以定制以满足不同字节码流的加载方式，比如从网络加载、从文件加载。ClassLoader的负责整个类装载流程中的“加载”阶段。

- 启动类加载器：用C++语言实现，是虚拟机自身的一部分，它负责 <JAVA_HOME>/lib路径下的核心类库，无法被Java程序直接引用。
- 扩展类加载器：用Java语言实现，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用。
- 系统类加载器：用Java语言实现，它负责加载系统类路径ClassPath指定路径下的类库，开发者可以直接使用

## 双亲委派
- 定义：如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

- 优点：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次防止恶意覆盖Java核心API。

- 问题： 顶层ClassLoader，无法加载底层ClassLoader的类

![](https://images2017.cnblogs.com/blog/352511/201708/352511-20170825174114668-2095214620.jpg)

![](https://images2017.cnblogs.com/blog/352511/201708/352511-20170825174115871-344382740.png)



