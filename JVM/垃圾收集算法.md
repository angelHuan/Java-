# 垃圾收集算法

## 1. 标记-清除(Mark-Sweep)
- 算法分为“标记” 和 “清除”两个过程：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
- ** 缺点 **
  - 效率比较低
  - 空间问题：标记清除后会产生大量不连续的内存碎片

## 2.复制算法（新生代）
- 复制算法最初是将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存一次性清理掉。
- ** 缺点 **
  - 浪费空间
- 复制算法主要用于回收新生代，回收内存时，会暂停其他所有线程的执行。
- HotSpot虚拟机将新生代分为Eden 和 Survivor， 比例为8：1：1。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另外一块 Survivor 空间上，最后清理掉刚才使用过的 Eden 空间和 Survivor 空间。当 Survivor 空间不够用时，需要依赖老年代来进行分配担保（Handle Promotion）

## 3. 标记-整理算法（Mark-Compact）(老年代)
- 根据老年代的特点提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
- 整理顺序
  - 任意顺序：对象的移动方式和它们初始的对象排列及引用关系无关
  - 线性顺序：将具有关联关系的对象排列在一起
  - 滑动顺序：将对象“滑动”到堆的一端，从而“挤出”垃圾，可以保持对象在堆中原有的顺序（基本都使用这个）

# 分代收集算法
- 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。


